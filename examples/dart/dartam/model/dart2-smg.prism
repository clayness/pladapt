smg

const double P_LOOSE_DESTROY; // = 1.0
const double P_LOOSE_DETECT ; // = 1.0
const double P_TIGHT_DESTROY; // = 0.4
const double P_TIGHT_DETECT ; // = 0.4

const int ALT_LATENCY  ; // = 2;
const int HORIZON      ; // = 10;
const int INIT_A       ; // = 3;
const int INIT_F       ; // = 0;
const int INIT_T       ; // = 0;
const int MAX_ALT_LEVEL; // = 3;
const int RANGE_SENSOR   = MAX_ALT_LEVEL;
const int RANGE_THREAT   = MAX_ALT_LEVEL;
const int TOTAL_THREATS; // = 2;
const int TOTAL_TARGETS; // = 6;

//************************************************************************
// CLOCK
//************************************************************************
const int CLK_TURN=0;
const int ENV_TURN=1;
const int SYS_TURN=2;
const int RWD_TURN=3;

global turn : [CLK_TURN..RWD_TURN] init CLK_TURN;

// finish when we've reached the horizon and it is
// time to place the guns
label "final" = clk_time=HORIZON & turn=CLK_TURN;

// clk: increments the clock time and advances to the "environment" turn
module clk
    clk_time : [0..HORIZON] init INIT_T;
    [] (turn=CLK_TURN) & (clk_time<HORIZON) -> 
        1 : (clk_time'=clk_time+1) & (turn'=ENV_TURN);
endmodule

//************************************************************************
// ENVIRONMENT
//************************************************************************
global has_target: bool init false;
global has_threat: bool init false;

formula P_THREAT = (HORIZON-clk_time>TOTAL_THREATS-threats_placed)?(TOTAL_THREATS/HORIZON):1;
formula P_TARGET = (HORIZON-clk_time>TOTAL_TARGETS-targets_placed)?(TOTAL_TARGETS/HORIZON):1;

// env: synchronizes the environment modules and advances to the "system" turn
module env
    [do_env] (turn=ENV_TURN) ->
        1 : (turn'=SYS_TURN);
endmodule

// env_threats: determines whether the current segment has a threat
module env_threats
    threats_placed: [0..TOTAL_THREATS] init 0;
    [do_env] (turn=ENV_TURN) & (threats_placed< TOTAL_THREATS) ->
        (P_THREAT)   : (has_threat'=true) & (threats_placed'=(threats_placed+1)) +
        (1-P_THREAT) : (has_threat'=false);
    [do_env] (turn=ENV_TURN) & (threats_placed>=TOTAL_THREATS) ->
        1 : (has_threat'=false);
endmodule

// env_targets: determins whether the current segment has a target for detection
module env_targets
    targets_placed: [0..TOTAL_TARGETS] init 0;
    [do_env] (turn=ENV_TURN) & (targets_placed< TOTAL_TARGETS) ->
        (P_TARGET)   : (has_target'=true) & (targets_placed'=(targets_placed+1))  +
        (1-P_TARGET) : (has_target'=false);
    [do_env] (turn=ENV_TURN) & (targets_placed>=TOTAL_TARGETS) ->
        1 : (has_target'=false);
endmodule

//************************************************************************
// SYSTEM
//************************************************************************
const a_MIN=1; const a_MAX=MAX_ALT_LEVEL;

// sys: synchronizes the system modules and advances the turn to the "reward" stage
module sys
    [do_sys] (turn=SYS_TURN) ->
        1 : (turn'=RWD_TURN);
endmodule

// sys_altitude: non-deterministically chooses to increase, decrease, or hold altitude
// and advances the progress if a change in altitude is underway
module sys_altitude
    a : [a_MIN..a_MAX] init INIT_A;
    a_progress : [-ALT_LATENCY..ALT_LATENCY] init 0;

    // keep the altitude the same, increase, or decrease
    [do_sys] (turn=SYS_TURN) & (a_progress=0) ->
        true;
    [do_sys] (turn=SYS_TURN) & (a<a_MAX) & (a_progress=0) ->
        1 : (a_progress'=( ALT_LATENCY));
    [do_sys] (turn=SYS_TURN) & (a>a_MIN) & (a_progress=0) ->
        1 : (a_progress'=(-ALT_LATENCY));

    // progress
    [do_sys] (turn=SYS_TURN) & (a_progress>1) ->
	1 : (a_progress'=(a_progress-1));
    [do_sys] (turn=SYS_TURN) & (a_progress<(-1)) ->
	1 : (a_progress'=(a_progress+1));

    // finish
    [do_sys] (turn=SYS_TURN) & (a_progress=1) ->
        1 : (a_progress'=0) & (a'=(a+1));
    [do_sys] (turn=SYS_TURN) & (a_progress=(-1)) ->
        1 : (a_progress'=0) & (a'=(a-1));
endmodule

// sys_formation: non-deterministically chooses to either change or retain formation
module sys_formation
    f : [0..1] init INIT_F;

    // keep the formation the same, go tight, or go loose
    [do_sys] (turn=SYS_TURN) ->
        true;
    [do_sys] (turn=SYS_TURN) & f=0 ->
        1 : (f'=1);
    [do_sys] (turn=SYS_TURN) & f=1 ->
        1 : (f'=0);
endmodule

//************************************************************************
// REWARD
//************************************************************************
formula P_DESTROY = (f=0?P_LOOSE_DESTROY:P_TIGHT_DESTROY) * max(0.0, ((RANGE_THREAT-(a-1))/RANGE_THREAT));
formula P_DETECT  = (f=0?P_LOOSE_DETECT :P_TIGHT_DETECT ) * max(0.0, ((RANGE_SENSOR-(a-1))/RANGE_SENSOR));

// rwd: synchronizes the reward modules and resets to the "clock" turn (for the next step)
module rwd
    [do_rwd] (turn=RWD_TURN) ->
        1 : (turn'=CLK_TURN);
endmodule

// rwd_threat: determines whether or not the threats destroyed the drones
module rwd_threat
    destroyed: bool init false;
    [do_rwd] (turn=RWD_TURN) & (!destroyed) & has_threat -> 
	true;
    [do_rwd] (turn=RWD_TURN) & (!destroyed) & has_threat ->
        (P_DESTROY)   : (destroyed'=true) +
        (1-P_DESTROY) : (destroyed'=false);
    [do_rwd] (turn=RWD_TURN) & (destroyed | !has_threat) -> 
	true;
endmodule

// rwd_sensor: determines whether or not the drones detected a target
module rwd_sensor
    detected : bool init false;
    [do_rwd] (turn=RWD_TURN) & has_target ->
        1 : (detected'=true);
    [do_rwd] (turn=RWD_TURN) & has_target -> 
        (P_DETECT)   : (detected'=true) +
        (1-P_DETECT) : (detected'=false);
    [do_rwd] (turn=RWD_TURN) & !has_target ->
        1 : (detected'=false);
endmodule

rewards "utility"
    [] (turn=CLK_TURN) & (!destroyed) & (detected): 1;
endrewards

player ground clk, env, env_threats, env_targets, rwd, rwd_threat, rwd_sensor, [do_env], [do_rwd] endplayer
player drones sys, sys_altitude, sys_formation, [do_sys] endplayer
